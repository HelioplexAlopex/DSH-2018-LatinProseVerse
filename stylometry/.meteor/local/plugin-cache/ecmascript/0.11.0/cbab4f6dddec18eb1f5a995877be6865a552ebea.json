{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/jeff/stylometry/imports/ui/pages/helpers.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"imports/ui/pages/helpers.js","filename":"/home/jeff/stylometry/imports/ui/pages/helpers.js","passPerPreset":false,"envName":"development","cwd":"/home/jeff/stylometry","root":"/home/jeff/stylometry","generatorOpts":{"filename":"/home/jeff/stylometry/imports/ui/pages/helpers.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/ui/pages/helpers.js"}},"code":"module.export({\n  naturalSort: () => naturalSort\n});\n\nconst naturalSort = function (a, b) {\n  var re = /(^([+\\-]?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?(?=\\D|\\s|$))|^0x[\\da-fA-F]+$|\\d+)/g,\n      sre = /^\\s+|\\s+$/g,\n      // trim pre-post whitespace\n  snre = /\\s+/g,\n      // normalize all whitespace to single ' ' character\n  dre = /(^([\\w ]+,?[\\w ]+)?[\\w ]+,?[\\w ]+\\d+:\\d+(:\\d+)?[\\w ]?|^\\d{1,4}[\\/\\-]\\d{1,4}[\\/\\-]\\d{1,4}|^\\w+, \\w+ \\d+, \\d{4})/,\n      hre = /^0x[0-9a-f]+$/i,\n      ore = /^0/,\n      i = function (s) {\n    return (naturalSort.insensitive && ('' + s).toLowerCase() || '' + s).replace(sre, '');\n  },\n      // convert all to strings strip whitespace\n  x = i(a),\n      y = i(b),\n      // chunk/tokenize\n  xN = x.replace(re, '\\0$1\\0').replace(/\\0$/, '').replace(/^\\0/, '').split('\\0'),\n      yN = y.replace(re, '\\0$1\\0').replace(/\\0$/, '').replace(/^\\0/, '').split('\\0'),\n      // numeric, hex or date detection\n  xD = parseInt(x.match(hre), 16) || xN.length !== 1 && Date.parse(x),\n      yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,\n      normChunk = function (s, l) {\n    // normalize spaces; find floats not starting with '0', string or 0 if not defined (Clint Priest)\n    return (!s.match(ore) || l == 1) && parseFloat(s) || s.replace(snre, ' ').replace(sre, '') || 0;\n  },\n      oFxNcL,\n      oFyNcL; // first try and sort Hex codes or Dates\n\n\n  if (yD) {\n    if (xD < yD) {\n      return -1;\n    } else if (xD > yD) {\n      return 1;\n    }\n  } // natural sorting through split numeric strings and default strings\n\n\n  for (var cLoc = 0, xNl = xN.length, yNl = yN.length, numS = Math.max(xNl, yNl); cLoc < numS; cLoc++) {\n    oFxNcL = normChunk(xN[cLoc] || '', xNl);\n    oFyNcL = normChunk(yN[cLoc] || '', yNl); // handle numeric vs string comparison - number < string - (Kyle Adams)\n\n    if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {\n      return isNaN(oFxNcL) ? 1 : -1;\n    } // if unicode use locale comparison\n\n\n    if (/[^\\x00-\\x80]/.test(oFxNcL + oFyNcL) && oFxNcL.localeCompare) {\n      var comp = oFxNcL.localeCompare(oFyNcL);\n      return comp / Math.abs(comp);\n    }\n\n    if (oFxNcL < oFyNcL) {\n      return -1;\n    } else if (oFxNcL > oFyNcL) {\n      return 1;\n    }\n  }\n};","map":{"version":3,"sources":["imports/ui/pages/helpers.js"],"names":["module","export","naturalSort","a","b","re","sre","snre","dre","hre","ore","i","s","insensitive","toLowerCase","replace","x","y","xN","split","yN","xD","parseInt","match","length","Date","parse","yD","normChunk","l","parseFloat","oFxNcL","oFyNcL","cLoc","xNl","yNl","numS","Math","max","isNaN","test","localeCompare","comp","abs"],"mappings":"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","sourcesContent":["\n\nexport const naturalSort = function(a, b) {\n    var re = /(^([+\\-]?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?(?=\\D|\\s|$))|^0x[\\da-fA-F]+$|\\d+)/g,\n        sre = /^\\s+|\\s+$/g,   // trim pre-post whitespace\n        snre = /\\s+/g,        // normalize all whitespace to single ' ' character\n        dre = /(^([\\w ]+,?[\\w ]+)?[\\w ]+,?[\\w ]+\\d+:\\d+(:\\d+)?[\\w ]?|^\\d{1,4}[\\/\\-]\\d{1,4}[\\/\\-]\\d{1,4}|^\\w+, \\w+ \\d+, \\d{4})/,\n        hre = /^0x[0-9a-f]+$/i,\n        ore = /^0/,\n        i = function(s) {\n            return (naturalSort.insensitive && ('' + s).toLowerCase() || '' + s).replace(sre, '');\n        },\n        // convert all to strings strip whitespace\n        x = i(a),\n        y = i(b),\n        // chunk/tokenize\n        xN = x.replace(re, '\\0$1\\0').replace(/\\0$/,'').replace(/^\\0/,'').split('\\0'),\n        yN = y.replace(re, '\\0$1\\0').replace(/\\0$/,'').replace(/^\\0/,'').split('\\0'),\n        // numeric, hex or date detection\n        xD = parseInt(x.match(hre), 16) || (xN.length !== 1 && Date.parse(x)),\n        yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,\n        normChunk = function(s, l) {\n            // normalize spaces; find floats not starting with '0', string or 0 if not defined (Clint Priest)\n            return (!s.match(ore) || l == 1) && parseFloat(s) || s.replace(snre, ' ').replace(sre, '') || 0;\n        },\n        oFxNcL, oFyNcL;\n    // first try and sort Hex codes or Dates\n    if (yD) {\n        if (xD < yD) { return -1; }\n        else if (xD > yD) { return 1; }\n    }\n    // natural sorting through split numeric strings and default strings\n    for(var cLoc = 0, xNl = xN.length, yNl = yN.length, numS = Math.max(xNl, yNl); cLoc < numS; cLoc++) {\n        oFxNcL = normChunk(xN[cLoc] || '', xNl);\n        oFyNcL = normChunk(yN[cLoc] || '', yNl);\n        // handle numeric vs string comparison - number < string - (Kyle Adams)\n        if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {\n            return isNaN(oFxNcL) ? 1 : -1;\n        }\n        // if unicode use locale comparison\n        if (/[^\\x00-\\x80]/.test(oFxNcL + oFyNcL) && oFxNcL.localeCompare) {\n            var comp = oFxNcL.localeCompare(oFyNcL);\n            return comp / Math.abs(comp);\n        }\n        if (oFxNcL < oFyNcL) { return -1; }\n        else if (oFxNcL > oFyNcL) { return 1; }\n    }\n}\n"]},"sourceType":"script","hash":"cbab4f6dddec18eb1f5a995877be6865a552ebea"}
